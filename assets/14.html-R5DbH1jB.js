import{_ as d,r as l,o as r,c as k,a as n,b as s,d as a,w as e,e as c}from"./app-vMeOxso3.js";const i="/assets/react-10-xKKVCz2w.png",v="/assets/react-11-OAq9Hae0.png",m="/assets/react-9-_qIH7yS-.png",b={},g=n("h1",{id:"_14-实现同步调度流程",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_14-实现同步调度流程","aria-hidden":"true"},"#"),s(" 14. 实现同步调度流程")],-1),h={class:"hint-container info"},y=n("p",{class:"hint-container-title"},"摘要",-1),f=n("ul",null,[n("li",null,"实现 Lane 模型"),n("li",null,"改造更新链表"),n("li",null,"实现调度阶段"),n("li",null,"改造更新流程")],-1),w={href:"https://github.com/2xiao/my-react/tree/v1.14",target:"_blank",rel:"noopener noreferrer"},L=n("code",null,"git tag v1.14",-1),S=c('<p>目前我们实现的更新流程中，从触发更新到 Render 阶段和 Commit 阶段，都是同步的，多次触发更新会重复多次执行更新流程。</p><figure><img src="'+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>为了提升性能，React 使用了批处理（Batched Updates）机制，批处理的目标是将多个更新操作合并成一个单一的更新，从而减少不必要的计算和渲染次数，提高应用的性能和响应速度。主要包括以下几个方面：</p><ol><li><p><strong>合并更新：</strong> 当调用 <code>setState()</code> 函数时，React 不会立即执行更新操作，而是将更新请求放入一个队列中等待执行，并将多个更新请求合并成一个更新。例如，如果一个组件在同一个事件循环中多次调用 <code>setState()</code>，React 只会执行一次更新，并以最新的状态进行渲染</p></li><li><p><strong>异步执行：</strong> React 将更新操作延迟到浏览器的下一个事件循环中执行，以确保 UI 渲染时是最新的状态。</p></li><li><p><strong>优先级调度：</strong> React 会根据更新的优先级和时间戳等因素进行调度，以保证在有限的时间内完成尽可能多的更新。这样可以确保及时响应用户操作，并保持良好的用户体验。</p></li></ol><h2 id="_1-实现-lane-模型" tabindex="-1"><a class="header-anchor" href="#_1-实现-lane-模型" aria-hidden="true">#</a> 1. 实现 Lane 模型</h2><p>Lane 是一个二进制的数字，表示一种优先级或者更新的类型，是用于调度和执行更新的一种机制，Lane 的数值越小，代表优先级越高；Lanes 可以看作是多个 Lane 的集合，用于表示系统中所有可能的更新任务的优先级。</p><p>通常情况下，可以将更新任务划分为不同的优先级，例如：高优先级更新、中等优先级更新和低优先级更新等。每个优先级都对应一个 Lane，当有更新任务产生时，会根据任务的优先级选择合适的 Lane，并将任务放入该 Lane 中，然后会根据 Lanes 中 Lane 的优先级顺序在合适的时机依次处理。</p><p>新建一个 <code>fiberLanes.ts</code> 文件，在里面实现 Lane 相关的定义和方法：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> FiberRootNode <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./fiber&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 代表 update 的优先级</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Lane</span> <span class="token operator">=</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token comment">// 代表 lane 的集合</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Lanes</span> <span class="token operator">=</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> NoLane <span class="token operator">=</span> <span class="token number">0b0000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> NoLanes <span class="token operator">=</span> <span class="token number">0b0000</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> SyncLane <span class="token operator">=</span> <span class="token number">0b0001</span><span class="token punctuation">;</span>

<span class="token comment">// 获取 Lane 的集合</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mergeLanes</span><span class="token punctuation">(</span>laneA<span class="token operator">:</span> Lane<span class="token punctuation">,</span> laneB<span class="token operator">:</span> Lane<span class="token punctuation">)</span><span class="token operator">:</span> Lanes <span class="token punctuation">{</span>
	<span class="token keyword">return</span> laneA <span class="token operator">|</span> laneB<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取更新的优先级</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">requestUpdateLanes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> SyncLane<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取 lanes 中优先级最高的 lane</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getHighestPriorityLane</span><span class="token punctuation">(</span>lanes<span class="token operator">:</span> Lanes<span class="token punctuation">)</span><span class="token operator">:</span> Lane <span class="token punctuation">{</span>
	<span class="token comment">// 默认规则：数值越小，优先级越高</span>
	<span class="token keyword">return</span> lanes <span class="token operator">&amp;</span> <span class="token operator">-</span>lanes<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 从根节点的 pendingLanes 中移除某个 lane</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">markRootFinished</span><span class="token punctuation">(</span>root<span class="token operator">:</span> FiberRootNode<span class="token punctuation">,</span> lane<span class="token operator">:</span> Lane<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
	root<span class="token punctuation">.</span>pendingLanes <span class="token operator">&amp;=</span> <span class="token operator">~</span>lane<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-改造更新链表" tabindex="-1"><a class="header-anchor" href="#_2-改造更新链表" aria-hidden="true">#</a> 2. 改造更新链表</h2><p>每个 Fiber 节点的更新都保存在 <code>updateQueue</code> 属性中，当有新的更新时，会调用 <code>enqueueUpdate</code> 函数将 <code>update</code> 添加到 <code>updateQueue</code> 中。</p><p>但是目前我们实现的 <code>enqueueUpdate</code> 函数是直接将 <code>update</code> 赋值给 <code>updateQueue</code>，这样会覆盖掉之前的 <code>update</code>。</p><p>因此我们需要对 <code>enqueueUpdate</code> 函数进行修改，以确保新的更新能够正确地添加到更新队列中，可以采用一种链表的方式来组织更新队列，每个更新对象都保存着下一个更新对象的引用，从而形成一个链表结构，确保更新操作能够按顺序执行：</p><figure><img src="`+v+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// packages/react-reconciler/src/updateQueue.ts</span>
<span class="token comment">// 将 Update 添加到 UpdateQueue 中的方法</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> enqueueUpdate <span class="token operator">=</span> <span class="token operator">&lt;</span>State<span class="token operator">&gt;</span><span class="token punctuation">(</span>
	updateQueue<span class="token operator">:</span> UpdateQueue<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span><span class="token punctuation">,</span>
	update<span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> pending <span class="token operator">=</span> updateQueue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		update<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		update<span class="token punctuation">.</span>next <span class="token operator">=</span> pending<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		pending<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// pending 指向 update 环状链表的最后一个节点</span>
	updateQueue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending <span class="token operator">=</span> update<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，我们将新的 <code>update</code> 添加到了更新链表的末尾，并将 <code>update.next</code> 指针指向链表中的第一个更新对象，最后将 <code>updateQueue.shared.pending</code> 指向 <code>update</code>，也就是链表的最后一个更新，这样可以方便我们添加和获取更新。</p><p>接着，我们为 <code>Update</code> 数据结构增加 <code>next</code> 和 <code>lane</code> 两个字段，同时修改创建 <code>Update</code> 实例的方法：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// packages/react-reconciler/src/updateQueue.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Lane <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./fiberLanes&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 定义 Update 数据结构</span>
<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
	action<span class="token operator">:</span> Action<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span><span class="token punctuation">;</span>
	next<span class="token operator">:</span> Update<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	lane<span class="token operator">:</span> Lane<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建 Update 实例的方法</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> createUpdate <span class="token operator">=</span> <span class="token operator">&lt;</span>State<span class="token operator">&gt;</span><span class="token punctuation">(</span>
	action<span class="token operator">:</span> Action<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span><span class="token punctuation">,</span>
	lane<span class="token operator">:</span> Lane
<span class="token punctuation">)</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">{</span>
		action<span class="token punctuation">,</span>
		next<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
		lane
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>显然，所有调用 <code>createUpdate</code> 函数创建 <code>Update</code> 的地方，我们都需要增加 <code>lane</code> 参数，目前有两个方法可以触发更新： <code>updateContainer</code> 和 <code>dispatchSetState</code>，分别对应了首屏渲染阶段和组件更新阶段。</p>`,19),_=n("div",{class:"language-typescript line-numbers-mode","data-ext":"ts"},[n("pre",{class:"language-typescript"},[n("code",null,[n("span",{class:"token comment"},"// packages/react-reconciler/src/fiberHooks.ts"),s(`
`),n("span",{class:"token keyword"},"import"),s(),n("span",{class:"token punctuation"},"{"),s(" requestUpdateLanes "),n("span",{class:"token punctuation"},"}"),s(),n("span",{class:"token keyword"},"from"),s(),n("span",{class:"token string"},"'./fiberLanes'"),n("span",{class:"token punctuation"},";"),s(`

`),n("span",{class:"token comment"},"// 用于触发状态更新的逻辑"),s(`
`),n("span",{class:"token keyword"},"function"),s(),n("span",{class:"token generic-function"},[n("span",{class:"token function"},"dispatchSetState"),n("span",{class:"token generic class-name"},[n("span",{class:"token operator"},"<"),s("State"),n("span",{class:"token operator"},">")])]),n("span",{class:"token punctuation"},"("),s(`
	fiber`),n("span",{class:"token operator"},":"),s(" FiberNode"),n("span",{class:"token punctuation"},","),s(`
	updateQueue`),n("span",{class:"token operator"},":"),s(" UpdateQueue"),n("span",{class:"token operator"},"<"),s("State"),n("span",{class:"token operator"},">"),n("span",{class:"token punctuation"},","),s(`
	action`),n("span",{class:"token operator"},":"),s(" Action"),n("span",{class:"token operator"},"<"),s("State"),n("span",{class:"token operator"},">"),s(`
`),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
	`),n("span",{class:"token keyword"},"const"),s(" lane "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token function"},"requestUpdateLanes"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
	`),n("span",{class:"token keyword"},"const"),s(" update "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token function"},"createUpdate"),n("span",{class:"token punctuation"},"("),s("action"),n("span",{class:"token punctuation"},","),s(" lane"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
	`),n("span",{class:"token function"},"enqueueUpdate"),n("span",{class:"token punctuation"},"("),s("updateQueue"),n("span",{class:"token punctuation"},","),s(" update"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
	`),n("span",{class:"token comment"},"// 调度更新"),s(`
	`),n("span",{class:"token function"},"scheduleUpdateOnFiber"),n("span",{class:"token punctuation"},"("),s("fiber"),n("span",{class:"token punctuation"},","),s(" lane"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"highlight-lines"},[n("br"),n("div",{class:"highlight-line"}," "),n("br"),n("br"),n("br"),n("br"),n("br"),n("br"),n("br"),n("div",{class:"highlight-line"}," "),n("div",{class:"highlight-line"}," "),n("br"),n("br"),n("div",{class:"highlight-line"}," "),n("br")]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),x=n("div",{class:"language-typescript line-numbers-mode","data-ext":"ts"},[n("pre",{class:"language-typescript"},[n("code",null,[n("span",{class:"token comment"},"// packages/react-reconciler/src/fiberReconciler.ts"),s(`
`),n("span",{class:"token keyword"},"import"),s(),n("span",{class:"token punctuation"},"{"),s(" requestUpdateLanes "),n("span",{class:"token punctuation"},"}"),s(),n("span",{class:"token keyword"},"from"),s(),n("span",{class:"token string"},"'./fiberLanes'"),n("span",{class:"token punctuation"},";"),s(`

`),n("span",{class:"token keyword"},"export"),s(),n("span",{class:"token keyword"},"function"),s(),n("span",{class:"token function"},"updateContainer"),n("span",{class:"token punctuation"},"("),s(`
	element`),n("span",{class:"token operator"},":"),s(" ReactElementType "),n("span",{class:"token operator"},"|"),s(),n("span",{class:"token keyword"},"null"),n("span",{class:"token punctuation"},","),s(`
	root`),n("span",{class:"token operator"},":"),s(` FiberRootNode
`),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
	`),n("span",{class:"token keyword"},"const"),s(" hostRootFiber "),n("span",{class:"token operator"},"="),s(" root"),n("span",{class:"token punctuation"},"."),s("current"),n("span",{class:"token punctuation"},";"),s(`
	`),n("span",{class:"token keyword"},"const"),s(" lane "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token function"},"requestUpdateLanes"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
	`),n("span",{class:"token keyword"},"const"),s(" update "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token generic-function"},[n("span",{class:"token function"},"createUpdate"),n("span",{class:"token generic class-name"},[n("span",{class:"token operator"},"<"),s("ReactElementType "),n("span",{class:"token operator"},"|"),s(),n("span",{class:"token keyword"},"null"),n("span",{class:"token operator"},">")])]),n("span",{class:"token punctuation"},"("),s("element"),n("span",{class:"token punctuation"},","),s(" lane"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
	`),n("span",{class:"token function"},"enqueueUpdate"),n("span",{class:"token punctuation"},"("),s(`
		hostRootFiber`),n("span",{class:"token punctuation"},"."),s("updateQueue "),n("span",{class:"token keyword"},"as"),s(" UpdateQueue"),n("span",{class:"token operator"},"<"),s("ReactElementType "),n("span",{class:"token operator"},"|"),s(),n("span",{class:"token keyword"},"null"),n("span",{class:"token operator"},">"),n("span",{class:"token punctuation"},","),s(`
		update
	`),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
	`),n("span",{class:"token function"},"scheduleUpdateOnFiber"),n("span",{class:"token punctuation"},"("),s("hostRootFiber"),n("span",{class:"token punctuation"},","),s(" lane"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
	`),n("span",{class:"token keyword"},"return"),s(" element"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"highlight-lines"},[n("br"),n("div",{class:"highlight-line"}," "),n("br"),n("br"),n("br"),n("br"),n("br"),n("br"),n("div",{class:"highlight-line"}," "),n("div",{class:"highlight-line"}," "),n("br"),n("br"),n("br"),n("br"),n("div",{class:"highlight-line"}," "),n("br"),n("br")]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),R=c(`<p>这两个方法调用 <code>createUpdate</code> 函数创建 <code>update</code> 之后，会将更新加入 <code>updateQueue</code> 链表中，然后调用 <code>scheduleUpdateOnFiber</code> 函数开始调度更新。</p><p>接着，我们还需要对从 <code>updateQueue</code> 中消费 <code>update</code> 的流程进行改造。</p><ul><li>给<code>processUpdateQueue</code> 函数增加第三个参数 <code>renderLane</code>，代表当前更新的优先级；</li><li>由于 <code>updateQueue</code> 是一个链表，因此需要遍历链表，依次消费符合当前更新优先级的 <code>update</code>；</li><li>执行完所有 <code>update</code> 之后，将计算出的最终值赋值给 <code>result.memoizedState</code>。</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 从 UpdateQueue 中消费 Update 的方法</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> processUpdateQueue <span class="token operator">=</span> <span class="token operator">&lt;</span>State<span class="token operator">&gt;</span><span class="token punctuation">(</span>
	baseState<span class="token operator">:</span> State<span class="token punctuation">,</span>
	pendingUpdate<span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
	renderLane<span class="token operator">:</span> Lane
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span> memoizedState<span class="token operator">:</span> State <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> result<span class="token operator">:</span> ReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> processUpdateQueue<span class="token operator">&lt;</span>State<span class="token operator">&gt;&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
		memoizedState<span class="token operator">:</span> baseState
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pendingUpdate <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 第一个 update</span>
		<span class="token keyword">let</span> first <span class="token operator">=</span> pendingUpdate<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token keyword">let</span> pending <span class="token operator">=</span> first <span class="token keyword">as</span> Update<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
		<span class="token keyword">do</span> <span class="token punctuation">{</span>
			<span class="token keyword">const</span> updateLane <span class="token operator">=</span> pending<span class="token punctuation">.</span>lane<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>updateLane <span class="token operator">==</span> renderLane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">const</span> action <span class="token operator">=</span> pending<span class="token punctuation">.</span>action<span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>action <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token builtin">Function</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token comment">// action 是回调函数</span>
					baseState <span class="token operator">=</span> <span class="token function">action</span><span class="token punctuation">(</span>baseState<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
					<span class="token comment">// action 是状态值</span>
					baseState <span class="token operator">=</span> action<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&#39;不应该进入 updateLane !== renderLane 逻辑&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			pending <span class="token operator">=</span> pending<span class="token punctuation">.</span>next <span class="token keyword">as</span> Update<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pending <span class="token operator">!==</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	result<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> baseState<span class="token punctuation">;</span>
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样，每个调用 <code>processUpdateQueue</code> 函数消费 <code>Update</code> 的地方，都需要增加一个 <code>renderLane</code> 参数。有两个方法可以消费更新：<code>updateHostRoot</code> 和 <code>updateState</code>，分别对应了首屏渲染阶段和组件更新阶段。</p>`,5),U={href:"https://github.com/2xiao/my-react/commit/73e3dbe1457c87eb533e71784ab8a37f801e5ead",target:"_blank",rel:"noopener noreferrer"},Q=c('<h2 id="_3-实现调度阶段" tabindex="-1"><a class="header-anchor" href="#_3-实现调度阶段" aria-hidden="true">#</a> 3. 实现调度阶段</h2><p>在之前的更新流程中，每次触发更新后，<code>scheduleUpdateOnFiber</code> 函数会从当前节点向上遍历到根节点，然后调用 Render 阶段的入口 <code>renderRoot</code> 函数， 构建 Fiber 树、处理新旧虚拟 DOM 树之间的差异、生成更新计划；在 <code>renderRoot</code> 函数执行完之后又会调用 Commit 阶段的入口 <code>commitRoot</code> 函数，将更新同步到实际的 DOM 中。</p><p>现在为了实现批处理机制，将多个更新操作合并成一个更新，我们需要在 Render 阶段和 Commit 阶段的基础上增加 Schedule 阶段（调度阶段）。</p><figure><img src="'+m+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>为了方便调度优先级，我们将优先级队列保存在根节点上。根节点作为整个应用的入口，将更新的状态信息存储在根节点上统一管理，可以更快地访问和检查哪些更新需要被处理，减少在整个组件树中查找的时间。</p><p>为 <code>FiberRootNode</code> 数据结构增加 <code>pendingLanes</code> 和 <code>finishedLane</code> 两个字段，其中 <code>pendingLanes</code> 用于标识当前有哪些更新需要被处理，<code>finishedLane</code> 用于表示已经完成处理的更新。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// packages/react-reconciler/src/fiber.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Lane<span class="token punctuation">,</span> Lanes<span class="token punctuation">,</span> NoLane<span class="token punctuation">,</span> NoLanes <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./fiberLanes&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">FiberRootNode</span> <span class="token punctuation">{</span>
	container<span class="token operator">:</span> Container<span class="token punctuation">;</span>
	current<span class="token operator">:</span> FiberNode<span class="token punctuation">;</span>
	finishedWork<span class="token operator">:</span> FiberNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	pendingLanes<span class="token operator">:</span> Lanes<span class="token punctuation">;</span>
	finishedLane<span class="token operator">:</span> Lane<span class="token punctuation">;</span>
	<span class="token function">constructor</span><span class="token punctuation">(</span>container<span class="token operator">:</span> Container<span class="token punctuation">,</span> hostRootFiber<span class="token operator">:</span> FiberNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// ...</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>pendingLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>finishedLane <span class="token operator">=</span> NoLane<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><div class="highlight-line"> </div><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着，我们回到 <code>scheduleUpdateOnFiber</code> 函数，为函数增加 <code>lane</code> 参数。</p><p>因为所有更新的 <code>lane</code> 都被保存在根节点的 <code>pendingLanes</code> 中，所以每当触发更新时，我们都需要将此次更新的 <code>lane</code> 记录到 <code>FiberRootNode.pendingLanes</code> 中。这个工作由 <code>markRootUpdated</code> 函数完成：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// packages/react-reconciler/src/workLoop.ts</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>fiber<span class="token operator">:</span> FiberNode<span class="token punctuation">,</span> lane<span class="token operator">:</span> Lane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">markUpdateFromFiberToRoot</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">markRootUpdated</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">renderRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将更新的优先级(lane)记录到根节点上</span>
<span class="token keyword">function</span> <span class="token function">markRootUpdated</span><span class="token punctuation">(</span>root<span class="token operator">:</span> FiberRootNode<span class="token punctuation">,</span> lane<span class="token operator">:</span> Lane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	root<span class="token punctuation">.</span>pendingLanes <span class="token operator">=</span> <span class="token function">mergeLanes</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>pendingLanes<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><div class="highlight-line"> </div><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着就要调用 <code>renderRoot</code> 函数，进入 Render 阶段了。</p><p>但是我们不希望每次触发更新都执行一次更新流程，因此，要在这里插入一个调度流程，根据某种判断机制选出一个优先级，然后在一个宏任务或微任务中合并更新，只执行一次 <code>renderRoot</code>。</p><figure><img src="`+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>接下来，我们就来实现调度流程的入口 <code>ensureRootIsScheduled</code> 函数，实现原理如下：</p><ol><li><p><strong>获取最高优先级的更新</strong>：首先，从根节点的 <code>pendingLanes</code> 中选择一个最高优先级的更新，这里使用 <code>getHighestPriorityLane</code> 函数来选择优先级最高的更新；</p></li><li><p><strong>根据优先级调度任务</strong>：根据选择的优先级，有两种不同的调度方式：</p><ul><li><strong>同步优先级（SyncLane）</strong>：如果选择的优先级是同步优先级，通常意味着有一些紧急且立即需要处理的更新，那么就会使用微任务调度。在这种情况下，<code>renderRoot</code> 函数会被添加到微任务队列中调度执行，以确保它在当前任务执行完毕后立即执行。</li><li><strong>其他优先级</strong>：如果选择的优先级不是同步优先级，说明这个更新可以稍后处理，那么就需要使用宏任务调度。在这种情况下，可以使用类似 <code>setTimeout</code> 的机制来安排任务，在主事件循环的下一个循环周期内执行更新。</li></ul></li><li><p><strong>安排微任务</strong>：调用 <code>scheduleMicroTask</code> 函数安排一个微任务，在微任务中执行更新。</p></li></ol><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// packages/react-reconciler/src/workLoop.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> getHighestPriorityLane <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./fiberLanes&#39;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> scheduleSyncCallback<span class="token punctuation">,</span> flushSyncCallback <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./syncTaskQueue&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> scheduleMicroTask <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;hostConfig&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>fiber<span class="token operator">:</span> FiberNode<span class="token punctuation">,</span> lane<span class="token operator">:</span> Lane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">markUpdateFromFiberToRoot</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">markRootUpdated</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ensureRootIsScheduled</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Schedule 阶段入口</span>
<span class="token keyword">function</span> <span class="token function">ensureRootIsScheduled</span><span class="token punctuation">(</span>root<span class="token operator">:</span> FiberRootNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> updateLane <span class="token operator">=</span> <span class="token function">getHighestPriorityLane</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>pendingLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>updateLane <span class="token operator">==</span> NoLane<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>updateLane <span class="token operator">===</span> SyncLane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 同步优先级，用微任务调度</span>
		<span class="token function">scheduleSyncCallback</span><span class="token punctuation">(</span><span class="token function">renderRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">,</span> updateLane<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">scheduleMicroTask</span><span class="token punctuation">(</span>flushSyncCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token comment">// 其他优先级，用宏任务调度</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><div class="highlight-line"> </div><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div><div class="highlight-line"> </div></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们来实现 <code>scheduleSyncCallback</code> 函数和 <code>flushSyncCallback</code> 函数。</p><p>新建一个 <code>syncTaskQueue.ts</code> 文件，这个文件中保存了与同步任务相关的状态和函数。</p><ul><li><p><code>scheduleSyncCallback</code></p><ul><li><code>scheduleSyncCallback</code> 函数负责将传入的回调函数 <code>callback</code> 添加到 <code>syncQueue</code> 中，<code>syncQueue</code> 中保存了当前的同步任务队列。具体步骤如下：</li><li>如果 <code>syncQueue</code> 为 <code>null</code>，表示当前没有待执行的回调函数，需要创建一个新的队列来存储回调函数；</li><li>如果 <code>syncQueue</code> 已经存在，则直接将回调函数添加到队列的末尾。</li></ul></li><li><p><code>flushSyncCallback</code></p><ul><li><code>flushSyncCallback</code> 函数会遍历 <code>syncQueue</code> 中的同步任务队列，并依次执行队列中的回调函数；</li><li>我们使用 <code>isFlushingSyncQueue</code> 标志位来表示当前是否正在执行队列中的回调函数；</li><li>这样的设计可以确保在执行同步回调函数期间不会再次触发 <code>flushSyncCallback</code> 函数，并且在同步执行期间防止其他异步任务的插入，以保证同步执行的正确性和稳定性；</li><li>微任务执行完之后，重置 <code>syncQueue</code> 和 <code>isFlushingSyncQueue</code>。</li></ul></li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// packages/react-reconciler/src/syncTaskQueue.ts</span>
<span class="token comment">// 同步的任务队列</span>
<span class="token keyword">let</span> syncQueue<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> isFlushingSyncQueue<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token comment">// 调度同步的回调函数</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">scheduleSyncCallback</span><span class="token punctuation">(</span><span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>syncQueue <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		syncQueue <span class="token operator">=</span> <span class="token punctuation">[</span>callback<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	syncQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 遍历执行同步的回调函数</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">flushSyncCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isFlushingSyncQueue <span class="token operator">&amp;&amp;</span> syncQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		isFlushingSyncQueue <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token keyword">try</span> <span class="token punctuation">{</span>
			syncQueue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&#39;flushSyncCallback 报错&#39;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
			isFlushingSyncQueue <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			syncQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>scheduleMicroTask</code> 函数的作用是安排一个微任务，在当前任务执行完成后立即执行。</p><p>为了确保在各种不同的环境下都能够正确地安排微任务，并确保任务的及时执行，需要对不同的环境做出兼容，具体实现原理是：</p><ul><li>首先，检查全局环境中是否存在 <code>queueMicrotask</code> 函数，如果存在，则使用 <code>queueMicrotask</code> 函数来安排微任务；</li><li>否则，检查 <code>Promise</code> 构造函数是否存在并可用。如果可用，则创建一个 <code>Promise</code> 对象并立即将其解析（resolve），然后执行传入的回调函数。通过 <code>Promise.resolve(null).then(callback)</code> 的方式，可以将传入的回调函数作为微任务安排在微任务队列中；</li><li>如果以上二者都没有，那么将回退到使用 <code>setTimeout</code> 函数来安排任务。在这种情况下，会将传入的回调函数安排在下一个宏任务队列中，而不是微任务队列中。</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// packages/react-dom/src/hostConfig.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> scheduleMicroTask <span class="token operator">=</span>
	<span class="token keyword">typeof</span> queueMicrotask <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span>
		<span class="token operator">?</span> queueMicrotask
		<span class="token operator">:</span> <span class="token keyword">typeof</span> <span class="token builtin">Promise</span> <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span>
		<span class="token operator">?</span> <span class="token punctuation">(</span><span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
		<span class="token operator">:</span> setTimeout<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们已经实现了 Schedule 阶段，将多个更新合并到一个微任务中执行，现在我们来回顾一下 Schedule 阶段的流程，以下面这个函数组件为例：</p><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">1210</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>
			<span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
				<span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">count</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">count</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">count</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token punctuation">}</span></span>
		<span class="token punctuation">&gt;</span></span><span class="token plain-text">
			</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text">
		</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
	<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>每次点击 <code>div</code> 都会触发三次 <code>dispatchSetState</code> 更新，然后进入 <code>scheduleUpdateOnFiber</code> 函数中调度更新;</li><li>首先，<code>markRootUpdated</code> 函数会将每次更新的 <code>lane</code> 存入 <code>root.pendingLanes</code> 中，经过三次 <code>mergeLanes</code> 后的 <code>root.pendingLanes</code> 值为 <code>SyncLane</code>;</li><li>接着，调用 <code>ensureRootIsScheduled</code> 函数，开始调度阶段，因为此时的 <code>updateLane === SyncLane</code>，为同步任务，因此会安排一个微任务来执行更新；</li><li><code>scheduleSyncCallback</code> 函数会被执行三次，所以此时的 <code>syncQueue</code> 值为三个 <code>renderRoot</code> 回调函数数组（<code>[renderRoot, renderRoot, renderRoot]</code>）;</li><li><code>flushSyncCallback</code> 函数同样会被调用三次，但是因为有 <code>isFlushingSyncQueue</code> 标志位，所以函数只会执行一次；</li><li>最终，在 <code>scheduleMicroTask</code> 创建的微任务中，<code>syncQueue</code> 中的三个 <code>renderRoot</code> 回调函数会被遍历执行。</li></ul><p>也就是说，在微任务中，<code>renderRoot</code> 函数还是会被执行三次，这显然不符合预期，因此，我们还需要对 <code>renderRoot</code> 函数及之后的更新流程做一些改造。</p><h2 id="_4-改造更新流程" tabindex="-1"><a class="header-anchor" href="#_4-改造更新流程" aria-hidden="true">#</a> 4. 改造更新流程</h2><p>要解决上述问题，我们只需要在 <code>renderRoot</code> 函数第一次执行之后，也就是在进入 <code>commitRoot</code> 函数时，立即从根节点的 <code>pendingLanes</code> 中移除该更新的 <code>lane</code>，此时 <code>root.pendingLanes</code> 就为 <code>NoLane</code> 了。</p><p>然后在进入 <code>renderRoot</code> 函数时加一个判断：如果根节点的 <code>pendingLanes</code> 中最高优先级的 <code>lane</code> 不是 <code>SyncLane</code>，代表此时的 <code>pendingLanes</code> 中只剩一些比 <code>SyncLane</code> 低的 <code>lane</code> 或 <code>NoLane</code> 了， 直接 <code>return</code> 即可。</p><p>这样，我们就解决了 <code>renderRoot</code> 函数多次执行的问题，具体的代码实现如下：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">renderRoot</span><span class="token punctuation">(</span>root<span class="token operator">:</span> FiberRootNode<span class="token punctuation">,</span> lane<span class="token operator">:</span> Lane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> nextLane <span class="token operator">=</span> <span class="token function">getHighestPriorityLane</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>pendingLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>nextLane <span class="token operator">!==</span> SyncLane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 其他比 SyncLane 低的优先级或 NoLane，重新调度</span>
		<span class="token function">ensureRootIsScheduled</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">commitRoot</span><span class="token punctuation">(</span>root<span class="token operator">:</span> FiberRootNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">const</span> lane <span class="token operator">=</span> root<span class="token punctuation">.</span>finishedLane<span class="token punctuation">;</span>
	<span class="token function">markRootFinished</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 重置</span>
	root<span class="token punctuation">.</span>finishedLane <span class="token operator">=</span> NoLane<span class="token punctuation">;</span>

    <span class="token comment">// ...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>至此，我们就实现了同步调度流程，可以将多个更新合并，按照优先级在一个微任务中执行。</p><p>同步调度流程能够即时响应状态变化和更新，一些高优先级的任务会在微任务中立即执行，从而优化了应用的性能和响应速度。通过将多个状态更新或 DOM 操作合并为一次更新执行，减少了浏览器执行的重排（reflow）和重绘（repaint）次数，这可以大大提高性能，减少页面的闪烁和卡顿。</p>`,36),F=n("code",null,"git tag v1.14",-1),C={href:"https://github.com/2xiao/my-react/tree/v1.14",target:"_blank",rel:"noopener noreferrer"};function N(T,q){const t=l("ExternalLinkIcon"),u=l("CodeTabs");return r(),k("div",null,[g,n("div",h,[y,f,n("p",null,[s("相关代码可在 "),n("a",w,[L,a(t)]),s(" 查看")])]),S,a(u,{id:"95",data:[{id:"dispatchSetState"},{id:"updateContainer"}]},{title0:e(({value:o,isActive:p})=>[s("dispatchSetState")]),title1:e(({value:o,isActive:p})=>[s("updateContainer")]),tab0:e(({value:o,isActive:p})=>[_]),tab1:e(({value:o,isActive:p})=>[x]),_:1}),R,n("p",null,[s("这里不一一列举改造细节了，详见 "),n("a",U,[s("代码"),a(t)]),s("。")]),Q,n("p",null,[s("相关代码可在 "),F,s(" 查看，地址："),n("a",C,[s("https://github.com/2xiao/my-react/tree/v1.14"),a(t)])])])}const O=d(b,[["render",N],["__file","14.html.vue"]]);export{O as default};

const n=JSON.parse(`{"key":"v-517654c9","path":"/interview/js.html","title":"JavaScript 相关","lang":"zh-CN","frontmatter":{"title":"JavaScript 相关","icon":"javascript","order":1,"headerDepth":1,"description":"1. apply、call、bind 的区别是什么？ 查看答案 call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的 this 指向 那什么情况下需要改变this的指向呢？下面举个例子 var name = 'lucy'; var obj = { \\tname: 'martin', \\tsay: function () { \\t\\tconsole.log(this.name); \\t} }; obj.say(); // martin，this 指向 obj 对象 setTimeout(obj.say, 0); // lucy，this 指向 window 对象 从上面可以看到，正常情况say方法输出martin 但是我们把say放在setTimeout方法中，在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，这时候this指向window，所以输出lucy 我们实际需要的是this指向obj对象，这时候就需要该改变this指向了 setTimeout(obj.say.bind(obj), 0); // martin，this指向obj对象 # apply apply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入 改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次 function fn(...args) { \\tconsole.log(this, args); } let obj = { \\tmyname: '张三' }; fn.apply(obj, [1, 2]); // this会变成传入的obj，传入的参数必须是一个数组； fn(1, 2); // this指向window 当第一个参数为null、undefined的时候，默认指向window(在浏览器中) fn.apply(null, [1, 2]); // this指向window fn.apply(undefined, [1, 2]); // this指向window # call call方法的第一个参数也是this的指向，后面传入的是一个参数列表 跟apply一样，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次 function fn(...args) { \\tconsole.log(this, args); } let obj = { \\tmyname: '张三' }; fn.call(obj, 1, 2); // this会变成传入的obj，传入的参数必须是一个数组； fn(1, 2); // this指向window 同样的，当第一个参数为null、undefined的时候，默认指向window(在浏览器中) fn.call(null, [1, 2]); // this指向window fn.call(undefined, [1, 2]); // this指向window # bind bind 方法和 call 很相似，第一参数也是 this 的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入) 改变 this 指向后不会立即执行，而是返回一个永久改变 this 指向的函数 function fn(...args) { \\tconsole.log(this, args); } let obj = { \\tmyname: '张三' }; const bindFn = fn.bind(obj); // this 也会变成传入的 obj ，bind 不是立即执行需要执行一次 bindFn(1, 2); // this 指向 obj fn(1, 2); // this 指向 window 从上面可以看到，apply、call、bind三者的区别在于： 三者都可以改变函数的 this 对象指向 三者第一个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或 null，则默认指向全局 window 三者都可以传参，但是 apply 是数组，而 call 是参数列表，且 apply 和 call 是一次性传入参数，而 bind 可以分为多次传入 bind 返回绑定 this 之后的函数，apply、call 则是立即执行","head":[["meta",{"property":"og:url","content":"https://2xiao.github.io/interview/js.html"}],["meta",{"property":"og:site_name","content":"LeetCode-JS"}],["meta",{"property":"og:title","content":"JavaScript 相关"}],["meta",{"property":"og:description","content":"1. apply、call、bind 的区别是什么？ 查看答案 call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的 this 指向 那什么情况下需要改变this的指向呢？下面举个例子 var name = 'lucy'; var obj = { \\tname: 'martin', \\tsay: function () { \\t\\tconsole.log(this.name); \\t} }; obj.say(); // martin，this 指向 obj 对象 setTimeout(obj.say, 0); // lucy，this 指向 window 对象 从上面可以看到，正常情况say方法输出martin 但是我们把say放在setTimeout方法中，在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，这时候this指向window，所以输出lucy 我们实际需要的是this指向obj对象，这时候就需要该改变this指向了 setTimeout(obj.say.bind(obj), 0); // martin，this指向obj对象 # apply apply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入 改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次 function fn(...args) { \\tconsole.log(this, args); } let obj = { \\tmyname: '张三' }; fn.apply(obj, [1, 2]); // this会变成传入的obj，传入的参数必须是一个数组； fn(1, 2); // this指向window 当第一个参数为null、undefined的时候，默认指向window(在浏览器中) fn.apply(null, [1, 2]); // this指向window fn.apply(undefined, [1, 2]); // this指向window # call call方法的第一个参数也是this的指向，后面传入的是一个参数列表 跟apply一样，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次 function fn(...args) { \\tconsole.log(this, args); } let obj = { \\tmyname: '张三' }; fn.call(obj, 1, 2); // this会变成传入的obj，传入的参数必须是一个数组； fn(1, 2); // this指向window 同样的，当第一个参数为null、undefined的时候，默认指向window(在浏览器中) fn.call(null, [1, 2]); // this指向window fn.call(undefined, [1, 2]); // this指向window # bind bind 方法和 call 很相似，第一参数也是 this 的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入) 改变 this 指向后不会立即执行，而是返回一个永久改变 this 指向的函数 function fn(...args) { \\tconsole.log(this, args); } let obj = { \\tmyname: '张三' }; const bindFn = fn.bind(obj); // this 也会变成传入的 obj ，bind 不是立即执行需要执行一次 bindFn(1, 2); // this 指向 obj fn(1, 2); // this 指向 window 从上面可以看到，apply、call、bind三者的区别在于： 三者都可以改变函数的 this 对象指向 三者第一个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或 null，则默认指向全局 window 三者都可以传参，但是 apply 是数组，而 call 是参数列表，且 apply 和 call 是一次性传入参数，而 bind 可以分为多次传入 bind 返回绑定 this 之后的函数，apply、call 则是立即执行"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-04T05:28:47.000Z"}],["meta",{"property":"article:author","content":"2xiao"}],["meta",{"property":"article:modified_time","content":"2024-07-04T05:28:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JavaScript 相关\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-04T05:28:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"2xiao\\",\\"url\\":\\"https://github.com/2xiao\\"}]}"]]},"headers":[{"level":2,"title":"1. apply、call、bind 的区别是什么？","slug":"_1-apply、call、bind-的区别是什么","link":"#_1-apply、call、bind-的区别是什么","children":[]},{"level":2,"title":"2. 如何实现一个 bind ？","slug":"_2-如何实现一个-bind","link":"#_2-如何实现一个-bind","children":[]},{"level":2,"title":"3. 数组方法中哪些会改变原数组，哪些不会？","slug":"_3-数组方法中哪些会改变原数组-哪些不会","link":"#_3-数组方法中哪些会改变原数组-哪些不会","children":[]},{"level":2,"title":"4. var、let、const 的区别是什么？","slug":"_4-var、let、const-的区别是什么","link":"#_4-var、let、const-的区别是什么","children":[]},{"level":2,"title":"5. 如何遍历对象的属性？","slug":"_5-如何遍历对象的属性","link":"#_5-如何遍历对象的属性","children":[]},{"level":2,"title":"6. 使用 new 操作符时发生了什么？","slug":"_6-使用-new-操作符时发生了什么","link":"#_6-使用-new-操作符时发生了什么","children":[]},{"level":2,"title":"7. == 和 === 的区别是什么？","slug":"_7-和-的区别是什么","link":"#_7-和-的区别是什么","children":[]},{"level":2,"title":"8. 什么是原型? 什么是原型链？","slug":"_8-什么是原型-什么是原型链","link":"#_8-什么是原型-什么是原型链","children":[]},{"level":2,"title":"9. 什么是作用域? 什么是作用域链?","slug":"_9-什么是作用域-什么是作用域链","link":"#_9-什么是作用域-什么是作用域链","children":[]},{"level":2,"title":"10. typeof 与 instanceof 区别是什么？","slug":"_10-typeof-与-instanceof-区别是什么","link":"#_10-typeof-与-instanceof-区别是什么","children":[]},{"level":2,"title":"13. 如何实现一个 Promise ？","slug":"_13-如何实现一个-promise","link":"#_13-如何实现一个-promise","children":[]},{"level":2,"title":"14. 如何实现 async/await ？","slug":"_14-如何实现-async-await","link":"#_14-如何实现-async-await","children":[]},{"level":2,"title":"11. 说说你对事件循环的理解？","slug":"_11-说说你对事件循环的理解","link":"#_11-说说你对事件循环的理解","children":[{"level":3,"title":"Promise 的几道基础题","slug":"promise-的几道基础题","link":"#promise-的几道基础题","children":[]}]},{"level":2,"title":"12. JS 是如何处理异步的？","slug":"_12-js-是如何处理异步的","link":"#_12-js-是如何处理异步的","children":[]},{"level":2,"title":"15. 如何实现一个 AJAX ？","slug":"_15-如何实现一个-ajax","link":"#_15-如何实现一个-ajax","children":[]},{"level":2,"title":"16. ES6、ES7、ES8、ES9、ES10 分别有什么新特性？","slug":"_16-es6、es7、es8、es9、es10-分别有什么新特性","link":"#_16-es6、es7、es8、es9、es10-分别有什么新特性","children":[]},{"level":2,"title":"17. ES Module 和 CommonJS 的区别是什么？","slug":"_17-es-module-和-commonjs-的区别是什么","link":"#_17-es-module-和-commonjs-的区别是什么","children":[]},{"level":2,"title":"18. 对比 import、import() 和 requrie 的区别","slug":"_18-对比-import、import-和-requrie-的区别","link":"#_18-对比-import、import-和-requrie-的区别","children":[]},{"level":2,"title":"19. 如何实现防抖和节流？","slug":"_19-如何实现防抖和节流","link":"#_19-如何实现防抖和节流","children":[]},{"level":2,"title":"20. 深拷贝浅拷贝的区别是什么？","slug":"_20-深拷贝浅拷贝的区别是什么","link":"#_20-深拷贝浅拷贝的区别是什么","children":[]},{"level":2,"title":"21. 闭包","slug":"_21-闭包","link":"#_21-闭包","children":[]},{"level":2,"title":"22. Cookie、sessionStorage、localStorage 的区别是什么？","slug":"_22-cookie、sessionstorage、localstorage-的区别是什么","link":"#_22-cookie、sessionstorage、localstorage-的区别是什么","children":[]},{"level":2,"title":"23. JS 中 this 的情况","slug":"_23-js-中-this-的情况","link":"#_23-js-中-this-的情况","children":[]},{"level":2,"title":"24. Event Loop 的执行顺序是什么？","slug":"_24-event-loop-的执行顺序是什么","link":"#_24-event-loop-的执行顺序是什么","children":[]},{"level":2,"title":"25. 对比各种继承","slug":"_25-对比各种继承","link":"#_25-对比各种继承","children":[]},{"level":2,"title":"26. 自检题","slug":"_26-自检题","link":"#_26-自检题","children":[]}],"git":{"createdTime":1711722741000,"updatedTime":1720070927000,"contributors":[{"name":"2xiao","email":"827574297wxxtb@sina.com","commits":12}]},"readingTime":{"minutes":29.77,"words":8931},"filePathRelative":"interview/js.md","localizedDate":"2024年3月29日","excerpt":"<h2> 1. apply、call、bind 的区别是什么？</h2>\\n<details class=\\"hint-container details\\"><summary>查看答案</summary>\\n<p><code>call</code>、<code>apply</code>、<code>bind</code>作用是改变函数执行时的上下文，简而言之就是改变函数运行时的 <code>this</code> 指向</p>\\n<p>那什么情况下需要改变<code>this</code>的指向呢？下面举个例子</p>\\n<div class=\\"language-javascript line-numbers-mode\\" data-ext=\\"js\\"><pre class=\\"language-javascript\\"><code><span class=\\"token keyword\\">var</span> name <span class=\\"token operator\\">=</span> <span class=\\"token string\\">'lucy'</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token keyword\\">var</span> obj <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">{</span>\\n\\t<span class=\\"token literal-property property\\">name</span><span class=\\"token operator\\">:</span> <span class=\\"token string\\">'martin'</span><span class=\\"token punctuation\\">,</span>\\n\\t<span class=\\"token function-variable function\\">say</span><span class=\\"token operator\\">:</span> <span class=\\"token keyword\\">function</span> <span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n\\t\\tconsole<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">log</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">this</span><span class=\\"token punctuation\\">.</span>name<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n\\t<span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\nobj<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">say</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// martin，this 指向 obj 对象</span>\\n<span class=\\"token function\\">setTimeout</span><span class=\\"token punctuation\\">(</span>obj<span class=\\"token punctuation\\">.</span>say<span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// lucy，this 指向 window 对象</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>从上面可以看到，正常情况<code>say</code>方法输出<code>martin</code></p>\\n<p>但是我们把<code>say</code>放在<code>setTimeout</code>方法中，在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，这时候<code>this</code>指向<code>window</code>，所以输出<code>lucy</code></p>\\n<p>我们实际需要的是<code>this</code>指向<code>obj</code>对象，这时候就需要该改变<code>this</code>指向了</p>\\n<div class=\\"language-javascript line-numbers-mode\\" data-ext=\\"js\\"><pre class=\\"language-javascript\\"><code><span class=\\"token function\\">setTimeout</span><span class=\\"token punctuation\\">(</span>obj<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">say</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">bind</span><span class=\\"token punctuation\\">(</span>obj<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// martin，this指向obj对象</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div></div></div><h3># apply</h3>\\n<p><code>apply</code>接受两个参数，第一个参数是<code>this</code>的指向，第二个参数是函数接受的参数，以数组的形式传入</p>\\n<p>改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次</p>\\n<div class=\\"language-javascript line-numbers-mode\\" data-ext=\\"js\\"><pre class=\\"language-javascript\\"><code><span class=\\"token keyword\\">function</span> <span class=\\"token function\\">fn</span><span class=\\"token punctuation\\">(</span><span class=\\"token parameter\\"><span class=\\"token operator\\">...</span>args</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n\\tconsole<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">log</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">this</span><span class=\\"token punctuation\\">,</span> args<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n<span class=\\"token keyword\\">let</span> obj <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">{</span>\\n\\t<span class=\\"token literal-property property\\">myname</span><span class=\\"token operator\\">:</span> <span class=\\"token string\\">'张三'</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token function\\">fn</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">apply</span><span class=\\"token punctuation\\">(</span>obj<span class=\\"token punctuation\\">,</span> <span class=\\"token punctuation\\">[</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">2</span><span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// this会变成传入的obj，传入的参数必须是一个数组；</span>\\n<span class=\\"token function\\">fn</span><span class=\\"token punctuation\\">(</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">2</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// this指向window</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>当第一个参数为<code>null</code>、<code>undefined</code>的时候，默认指向<code>window</code>(在浏览器中)</p>\\n<div class=\\"language-javascript line-numbers-mode\\" data-ext=\\"js\\"><pre class=\\"language-javascript\\"><code><span class=\\"token function\\">fn</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">apply</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">null</span><span class=\\"token punctuation\\">,</span> <span class=\\"token punctuation\\">[</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">2</span><span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// this指向window</span>\\n<span class=\\"token function\\">fn</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">apply</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">undefined</span><span class=\\"token punctuation\\">,</span> <span class=\\"token punctuation\\">[</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">2</span><span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// this指向window</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><h3># call</h3>\\n<p><code>call</code>方法的第一个参数也是<code>this</code>的指向，后面传入的是一个参数列表</p>\\n<p>跟<code>apply</code>一样，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次</p>\\n<div class=\\"language-javascript line-numbers-mode\\" data-ext=\\"js\\"><pre class=\\"language-javascript\\"><code><span class=\\"token keyword\\">function</span> <span class=\\"token function\\">fn</span><span class=\\"token punctuation\\">(</span><span class=\\"token parameter\\"><span class=\\"token operator\\">...</span>args</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n\\tconsole<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">log</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">this</span><span class=\\"token punctuation\\">,</span> args<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n<span class=\\"token keyword\\">let</span> obj <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">{</span>\\n\\t<span class=\\"token literal-property property\\">myname</span><span class=\\"token operator\\">:</span> <span class=\\"token string\\">'张三'</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token function\\">fn</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">call</span><span class=\\"token punctuation\\">(</span>obj<span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">2</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// this会变成传入的obj，传入的参数必须是一个数组；</span>\\n<span class=\\"token function\\">fn</span><span class=\\"token punctuation\\">(</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">2</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// this指向window</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>同样的，当第一个参数为<code>null</code>、<code>undefined</code>的时候，默认指向<code>window</code>(在浏览器中)</p>\\n<div class=\\"language-javascript line-numbers-mode\\" data-ext=\\"js\\"><pre class=\\"language-javascript\\"><code><span class=\\"token function\\">fn</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">call</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">null</span><span class=\\"token punctuation\\">,</span> <span class=\\"token punctuation\\">[</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">2</span><span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// this指向window</span>\\n<span class=\\"token function\\">fn</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">call</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">undefined</span><span class=\\"token punctuation\\">,</span> <span class=\\"token punctuation\\">[</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">2</span><span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// this指向window</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><h3># bind</h3>\\n<p><code>bind</code> 方法和 <code>call</code> 很相似，第一参数也是 <code>this</code> 的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)</p>\\n<p>改变 <code>this</code> 指向后不会立即执行，而是返回一个永久改变 <code>this</code> 指向的函数</p>\\n<div class=\\"language-javascript line-numbers-mode\\" data-ext=\\"js\\"><pre class=\\"language-javascript\\"><code><span class=\\"token keyword\\">function</span> <span class=\\"token function\\">fn</span><span class=\\"token punctuation\\">(</span><span class=\\"token parameter\\"><span class=\\"token operator\\">...</span>args</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n\\tconsole<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">log</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">this</span><span class=\\"token punctuation\\">,</span> args<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n<span class=\\"token keyword\\">let</span> obj <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">{</span>\\n\\t<span class=\\"token literal-property property\\">myname</span><span class=\\"token operator\\">:</span> <span class=\\"token string\\">'张三'</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token keyword\\">const</span> bindFn <span class=\\"token operator\\">=</span> <span class=\\"token function\\">fn</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">bind</span><span class=\\"token punctuation\\">(</span>obj<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// this 也会变成传入的 obj ，bind 不是立即执行需要执行一次</span>\\n<span class=\\"token function\\">bindFn</span><span class=\\"token punctuation\\">(</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">2</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// this 指向 obj</span>\\n<span class=\\"token function\\">fn</span><span class=\\"token punctuation\\">(</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">2</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">// this 指向 window</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>从上面可以看到，<code>apply</code>、<code>call</code>、<code>bind</code>三者的区别在于：</p>\\n<ul>\\n<li>三者都可以改变函数的 <code>this</code> 对象指向</li>\\n<li>三者第一个参数都是 <code>this</code> 要指向的对象，如果如果没有这个参数或参数为 <code>undefined</code> 或 <code>null</code>，则默认指向全局 <code>window</code></li>\\n<li>三者都可以传参，但是 <code>apply</code> 是数组，而 <code>call</code> 是参数列表，且 <code>apply</code> 和 <code>call</code> 是一次性传入参数，而 <code>bind</code> 可以分为多次传入</li>\\n<li><code>bind</code> 返回绑定 <code>this</code> 之后的函数，<code>apply</code>、<code>call</code> 则是立即执行</li>\\n</ul>\\n</details>","autoDesc":true}`);export{n as data};
